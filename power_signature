/* Includes ------------------------------------------------------------- */
#include <odrive_3_inferencing.h>
#include <HardwareSerial.h>
#include <ODriveArduino.h>
#include <Wire.h>
#include <Arduino.h>

// Edge Impulse parameters
#define FREQUENCY_HZ        EI_CLASSIFIER_FREQUENCY
#define INTERVAL_MS         (1000 / (FREQUENCY_HZ + 1))
static float features[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE] = {};
static unsigned long last_interval_ms = 0;
size_t feature_ix = 0;

// Setting up the ODrive object
HardwareSerial& odrive_serial = Serial1;
ODriveArduino odrive(odrive_serial);

// Initialize power variable
float power;

/* Function declarations ------------------------------------------------- */
int raw_feature_get_data(size_t offset, size_t length, float *out_ptr) {
    memcpy(out_ptr, features + offset, length * sizeof(float));
    return 0;
}

void ei_printf(const char *format, ...) {
    static char print_buf[1024] = { 0 };

    va_list args;
    va_start(args, format);
    int r = vsnprintf(print_buf, sizeof(print_buf), format, args);
    va_end(args);

    if (r > 0) {
        Serial.write(print_buf);
    }
}

// Run once
void setup()
{
    Serial.begin(115200);
    while (!Serial);
    Serial.println("Main serial connection opened.");
    
    odrive_serial.begin(115200);
    while (!odrive_serial);
    Serial.println("ODrive serial connection opened.");
}

// Run in a loop
void loop() {
    if (millis() > last_interval_ms + INTERVAL_MS) {
        last_interval_ms = millis();

        // Get power reading from ODrive
        power = odrive.GetElectricalPower(0);

        // Put power reading in feature array
        features[feature_ix++] = power;

        // Features buffer full? then classify!
        if (feature_ix == EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE) {
            ei_impulse_result_t result;

            // Create signal from features frame
            signal_t signal;
            numpy::signal_from_buffer(features, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, &signal);

            // Run classifier
            EI_IMPULSE_ERROR res = run_classifier(&signal, &result, false);
            ei_printf("run_classifier returned: %d\n", res);
            if (res != 0) return;

            // Print predictions
            ei_printf("Predictions (DSP: %d ms., Classification: %d ms., Anomaly: %d ms.): \n",
                result.timing.dsp, result.timing.classification, result.timing.anomaly);

            for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
                ei_printf("%s:\t%.5f\n", result.classification[ix].label, result.classification[ix].value);
            }
      
        #if EI_CLASSIFIER_HAS_ANOMALY == 1
            ei_printf("anomaly:\t%.3f\n", result.anomaly);
        #endif
            // reset features frame
            feature_ix = 0;
        }
    }
}
